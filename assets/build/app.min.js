/**
 * @name Aroskanalen
 * @version v3.3.0
 * @link https://github.com/aroskanalen
 */
/**
 * Defines the Angular Application.
 *
 * Dependency:
 *   A angularJS service to load dynamically CSS files. The original name of this
 *   project was angularDynamicStylesheets.
 */
angular.module('ikApp', [
    'ngAnimate',
    'angular.css.injector',

    'itkLog',

    'itkRegion',
    'itkDateComponent',
    'itkDigitalClockComponent',
    'itkKeypress'
  ]
).config(["$sceDelegateProvider", function ($sceDelegateProvider) {
    'use strict';

    // The administration interface and the client code do not run on the same
    // domain/sub-domain hence we need to whitelist the domains to load slide
    // templates and CSS form the administration domain.
    $sceDelegateProvider.resourceUrlWhitelist([
      // Allow same origin resource loads.
      'self',
      // Allow loading from outer templates domain.
      '**'
    ]);
  }]).config(["$provide", function ($provide) {
    'use strict';

    $provide.decorator("$exceptionHandler", ['$delegate', '$injector',
      function ($delegate, $injector) {
        return function (exception, cause) {
          $delegate(exception, cause);

          // Send the error to itkLog.
          $injector.get('itkLog').error(exception, cause);
        };
      }
    ]);
  }]);

/**
 * @file
 * Contains the index controller.
 */

/**
 * Index Controller.
 *
 * Sets up the socket connection and displays the activation page if relevant.
 */
angular.module('ikApp').controller('IndexController', ['$scope', '$rootScope', '$timeout', 'socket', 'itkLog', 'cssInjector',
  function ($scope, $rootScope, $timeout, socket, itkLog, cssInjector) {
    'use strict';

    // The template to render in the index.html's ng-include.
    $scope.template = 'app/pages/index/init.html?' + window.config.version;
    // Is the screen running (has the screen template been loaded?).
    $scope.running = false;

    $scope.fallbackImageUrl = window.config.fallback_image ? window.config.fallback_image : 'assets/images/fallback_default.png';

    // Stored channels for when the screen template has not yet been loaded.
    var savedChannelPushes = [];

    // Saved info about regions
    var regions = [];

    // Should the fallback image be displayed?
    $scope.displayFallbackImage = true;

    /**
     * Register to the regionInfo event.
     * Updates whether or not the fallback image should be displayed.
     */
    $rootScope.$on('regionInfo', function(event, info) {
      regions[info.id] = info;

      var hasScheduled = false;
      regions.forEach(function(region) {
        if (region.scheduledSlides > 0) {
          hasScheduled = true;
        }
      });

      $scope.displayFallbackImage = !hasScheduled;
    });

    /**
     * Register to the activationNotComplete event.
     */
    $rootScope.$on('activationNotComplete', function() {
      $scope.$apply(function () {
        $scope.template = 'app/pages/notActivated/not-activated.html?' + window.config.version;
      });
    });

    /**
     * Register to the awaitingContent event.
     */
    $rootScope.$on('awaitingContent', function() {
      $scope.$apply(function () {
        $scope.template = 'app/pages/index/awaiting-content.html?' + window.config.version;
      });
    });

    /**
     * Register to the start event.
     *
     * Applies the screen template and emits stored channels to regions after a 5 seconds delay.
     */
    $rootScope.$on('start', function(event, screen) {
      if (!$scope.running) {
        $scope.$apply(function () {
          // Inject the screen stylesheet.
          cssInjector.add(screen.template.path_css);

          // Set the screen template.
          $scope.template = screen.template.path_live;
          $scope.templateDirectory = screen.template.path;

          $scope.options = screen.options;
        });

        // Wait 5 seconds for the screen template to load.
        $timeout(function() {
          $scope.running = true;

          // Push all stored channels.
          for (var i = 0; i < savedChannelPushes.length; i++) {
            itkLog.info('emitting channel saved channel.');
            $rootScope.$emit('addChannel', savedChannelPushes[i]);
          }
        }, 5000);
      }
    });

    /**
     * Register to the addChannel event.
     *
     * If the screen template is not running yet, store the channel for
     *   emission after the screen template has been loaded.
     */
    $rootScope.$on('addChannel', function(event, data) {
      if (!$scope.running) {
        itkLog.info('saving channel till screen is ready.');
        savedChannelPushes.push(data);
      }
    });

    /**
     * Logout and reload the screen.
     */
    $scope.logout = function logout() {
      // Use the socket to logout.
      socket.logout();
    };

    // Start the socket connection to the middleware.
    socket.start();
  }
]);

/**
 * @file
 * Contains the NotActivatedController.
 */

/**
 * NotActivatedController.
 *
 * Controllers the notActivated page.
 */
angular.module('ikApp').controller('NotActivatedController', ['$scope', 'socket',
  function ($scope, socket) {
    'use strict';

    $scope.activationCode = '';

    /**
     * Submit handler for the activation screen.
     */
    $scope.submitActivationCode = function() {
      socket.activateScreenAndConnect($scope.activationCode);
    };
  }
]);

/**
 * @file
 * Contains the activeEvents filter.
 * A filter to display only events that have not yet bypassed their end date.
 */

/**
 * Add an active events filter to eventlist.
 */
angular.module('ikApp').filter('activeEvents', function() {
  return function(items) {
    'use strict';

    // Return if event array empty.
    if (!angular.isArray(items)){
      return false
    }

    // Get current time.
    var currentTime = parseInt(Date.now() / 1000);

    var ret = [];

    // Loop through event items.
    for (var i = 0; i < items.length; i++) {
      var item = items[i];

      // Calculate event duration.
      if (item.from && item.to && item.to >= currentTime) {
        ret.push(item);
      }
      else if (item.from && item.from >= currentTime) {
        ret.push(item);
      }
    }

    return ret;
  };
});
/**
 * @file
 * Contains the itkRegion module.
 */

/**
 * Setup the module.
 */
(function () {
  'use strict';

  var app;
  app = angular.module("itkRegion", []);

  /**
   * region directive.
   *
   * html parameters:
   *   region (integer): region id.
   *   show-progress (boolean): should the progress bar/box be displayed?
   */
  app.directive('region', ['$rootScope', '$timeout', '$interval', 'itkLog', '$http', '$sce',
    function ($rootScope, $timeout, $interval, itkLog, $http, $sce) {
      return {
        restrict: 'E',
        scope: {
          regionId: '=',
          showProgress: '=',
          scale: '='
        },
        templateUrl: 'app/shared/region/region.html?' + window.config.version,
        link: function (scope) {
          $rootScope.$broadcast('regionInfo', {
            "id": scope.regionId,
            "scheduledSlides": 0
          });

          // To get smooth transitions between slides, channels consist of two arrays, that are switched between.
          // The current array consist of the channels that are in the current rotation, and the other array
          //   contains future slides.
          scope.channels = [
            {},
            {}
          ];
          // Since channels are set by keys, we need arrays of the keys, that we can cycle between.
          scope.channelKeys = [
            [],
            []
          ];
          var channelKey = -1;

          scope.slideIndex = null;
          scope.channelIndex = null;
          scope.displayIndex = 0;
          scope.running = false;
          scope.slidesUpdated = false;

          var timeout = null;
          var fadeTime = 1000;

          // Used by progress bar
          scope.progressBoxElements = 0;
          scope.progressBoxElementsIndex = 0;

          /**
           * Sets the progress bar style.
           *
           * @param duration
           *   How many seconds should the animation take?
           */
          var startProgressBar = function startProgressBar(duration) {
            scope.progressBarStyle = {
              "overflow": "hidden",
              "-webkit-transition": "width " + duration + "s linear",
              "-moz-transition": "width " + duration + "s linear",
              "-o-transition": "width " + duration + "s linear",
              "transition": "width " + duration + "s linear",
              "width": "100%"
            };
          };

          /**
           * Resets the progress bar style.
           */
          var resetProgressBar = function resetProgressBar() {
            scope.progressBarStyle = {
              "width": "0"
            };
          };

          /**
           * Reset the progress box.
           */
          var resetProgressBox = function resetProgressBox() {
            itkLog.info('resetProgressBox');
            scope.progressBoxElements = 0;
            scope.progressBoxElementsIndex = 0;

            var numberOfScheduledSlides = 0;

            for (var i = 0; i < scope.channelKeys[scope.displayIndex].length; i++) {
              var channelKey = scope.channelKeys[scope.displayIndex][i];
              var channel = scope.channels[scope.displayIndex][channelKey];

              if (channel.isScheduled) {
                for (var j = 0; j < channel.slides.length; j++) {
                  var slide = channel.slides[j];
                  if (slide.isScheduled) {
                    numberOfScheduledSlides++;
                  }
                }
              }
            }

            scope.progressBoxElements = numberOfScheduledSlides;

            $rootScope.$broadcast('regionInfo', {
              "id": scope.regionId,
              "scheduledSlides": numberOfScheduledSlides
            });
          };

          /**
           * Is the slide scheduled to be shown?
           *
           * Returns true if the slide is scheduled to be shown now.
           *
           * @param slide
           * @returns {boolean}
           */
          var isSlideScheduled = function isSlideScheduled(slide) {
            var now = Math.round((new Date()).getTime() / 1000);
            var from = slide.schedule_from;
            var to = slide.schedule_to;

            var fromSet = from && from !== 0;
            var toSet = to && to !== 0;

            if (fromSet && !toSet) {
              return from < now;
            }

            if (fromSet && toSet) {
              return from < to && from < now && to > now;
            }

            if (!fromSet && toSet) {
              return to > now;
            }

            return true;
          };

          /**
           * Is the channel published to be shown now?
           *
           * @param channel
           *   The channel to evaluate.
           * @returns {boolean}
           */
          var isChannelPublished = function isChannelPublished(channel) {
            var now = Math.round((new Date()).getTime() / 1000);
            var publishFrom = channel.publish_from;
            var publishTo = channel.publish_to;

            if (!publishFrom && !publishTo) {
              return true;
            }

            if (publishFrom && now > publishFrom && (!publishTo || now < publishTo)) {
              return true;
            }

            return !publishFrom && now < publishTo;
          };

          /**
           * Is the channel scheduled to be shown now?
           *
           * @param channel
           *   The channel to evaluate.
           * @returns {boolean}
           */
          var isChannelScheduled = function isChannelScheduled(channel) {
            // If no schedule repeat is set, it should be shown all the time.
            if (!channel.schedule_repeat) {
              return true;
            }

            var now = new Date();
            var nowDay = now.getDay();
            var nowHour = now.getHours();

            var hourFrom = channel.schedule_repeat_from;
            var hourTo = channel.schedule_repeat_to;
            var days = channel.schedule_repeat_days;

            // If all 3 parameters are not set return.
            if (!hourFrom && !hourTo && days.length === 0) {
              return true;
            }

            // Should it be shown today?
            var repeatToday = false;
            for (var i = 0; i < days.length; i++) {
              if (days[i].id === nowDay) {
                repeatToday = true;
                break;
              }
            }

            // Is it within scheduled hours?
            if (repeatToday) {
              if (hourFrom > hourTo) {
                return false;
              }

              return nowHour >= hourFrom && nowHour < hourTo;
            }

            return false;
          };

          /**
           * Update which channels are scheduled to be shown.
           */
          var updateChannelsScheduled = function updateChannelsScheduled() {
            scope.channelKeys[scope.displayIndex].forEach(function (channelKey) {
              var channel = scope.channels[scope.displayIndex][channelKey];
              channel.isScheduled = isChannelPublished(channel) && isChannelScheduled(channel);
            });
          };

          /**
           * Update which slides are scheduled to be shown.
           */
          var updateSlidesScheduled = function updateSlidesScheduled() {
            var slidesScheduled = 0;
            scope.channelKeys[scope.displayIndex].forEach(function (channelKey) {
              var channel = scope.channels[scope.displayIndex][channelKey];

              channel.slides.forEach(function (slide) {
                slide.isScheduled = isSlideScheduled(slide);
              });
            });
          };

          /**
           * Check if there are any slides that are scheduled.
           */
          var slidesRemainToBeShown = function slidesRemainToBeShown() {
            var element;

            // Check all channels to see if there are slides to show.
            for (var i = 0; i < scope.channelKeys[scope.displayIndex].length; i++) {
              var channelIndex = scope.channelKeys[scope.displayIndex][i];
              var channel = scope.channels[scope.displayIndex][channelIndex];

              if (channel.isScheduled) {
                // Check if there are any slides scheduled in the current channel.
                for (var k = 0; k < channel.slides.length; k++) {
                  element = channel.slides[k];

                  if (element.isScheduled) {
                    return true;
                  }
                }
              }
            }

            return false;
          };

          /**
           * Restart the show.
           *
           * Restart the show from the start of the current channels array,
           *   or if there have been changes, go to the other channels array.
           */
          var restartShow = function restartShow() {
            itkLog.info("restart show");
            var otherDisplayIndex = (scope.displayIndex + 1) % 2;

            scope.slideIndex = -1;
            channelKey = -1;

            // Swap to updated channel array, if there have been changes to channels.
            if (scope.slidesUpdated) {
              scope.channels[scope.displayIndex] = angular.copy(scope.channels[otherDisplayIndex]);
              scope.channelKeys[scope.displayIndex] = Object.keys(scope.channels[scope.displayIndex]);

              scope.displayIndex = otherDisplayIndex;

              scope.slidesUpdated = false;
            }

            // Mark channels and slides that should not be show as isScheduled = false
            updateChannelsScheduled();
            updateSlidesScheduled();

            // Reset progress box
            resetProgressBox();

            // If no slides are to be displayed, wait 5 seconds and restart.
            if (!slidesRemainToBeShown()) {
              $timeout.cancel(timeout);
              timeout = $timeout(goRestartShow, 5000);
            }
            else {
              // Show next slide.
              nextChannel();
            }
          };

          /**
           * Calls restartShow.
           *
           * @TODO: Find way to avoid this call from restartShow().
           */
          var goRestartShow = function goRestartShow() {
            restartShow();
          };

          /**
           * Calls nextChannel.
           *
           * @TODO: Find way to avoid this call from nextChannel().
           */
          var goToNextChannel = function goToNextChannel() {
            nextChannel();
          };

          /**
           * Go to next channel
           *
           * Switch to the next channel or cycle to the first. S
           */
          var nextChannel = function nextChannel() {
            itkLog.info("next channel");

            channelKey++;

            // If more channels remain to be shown, go to next channel.
            if (channelKey < scope.channelKeys[scope.displayIndex].length) {
              var nextChannelIndex = scope.channelKeys[scope.displayIndex][channelKey];
              var nextChannel = scope.channels[scope.displayIndex][nextChannelIndex];
              if (nextChannel.isScheduled) {
                scope.channelIndex = nextChannelIndex;
                scope.slideIndex = -1;

                nextSlide();
              }
              else {
                $timeout.cancel(timeout);
                $timeout(goToNextChannel, 100);
              }
            }
            // Else restart the show.
            else {
              restartShow();
            }
          };

          /**
           * Set the next slide, and call displaySlide.
           */
          var nextSlide = function nextSlide() {
            itkLog.info("next slide");

            var nextSlideIndex = scope.slideIndex + 1;

            // If overlapping current channel.slides length
            if (!scope.channels[scope.displayIndex][scope.channelIndex] || nextSlideIndex >= scope.channels[scope.displayIndex][scope.channelIndex].slides.length) {
              nextChannel();
              return;
            }

            // If slides array is empty, wait 5 seconds, try again.
            if (scope.channels[scope.displayIndex][scope.channelIndex] === undefined || scope.channels[scope.displayIndex][scope.channelIndex].slides.length <= 0) {
              $timeout.cancel(timeout);
              timeout = $timeout(nextSlide, 5000);
              return;
            }

            // Get current slide.
            scope.slideIndex = nextSlideIndex;
            var currentSlide = scope.channels[scope.displayIndex][scope.channelIndex].slides[scope.slideIndex];

            // If slide is not scheduled,
            //   make sure a slide is scheduled, to be shown, then go to next slide.
            //   else wait 5 seconds and then go to next slide.
            // This is to avoid fast loop over slides that are not scheduled,
            //   when no slide are scheduled.
            if (!currentSlide.isScheduled) {
              if (slidesRemainToBeShown()) {
                itkLog.info('Slide schedule: slides remain.');
                nextSlide();
              }
              else {
                itkLog.info('Slide schedule: slides do not remain');
                // If no slide scheduled, wait 5 seconds, then restart show.
                $timeout.cancel(timeout);
                $timeout(function () {
                  restartShow();
                }, 5000);
              }
            }
            // If the slide is scheduled, show it.
            else {
              displaySlide();
            }
          };

          /**
           * Handle video error.
           *
           * @param event
           *   If defined it's a normal error event else it's offline down.
           */
          var videoErrorHandling = function videoErrorHandling(event) {
            if (event !== undefined) {
              // Normal javascript error event.
              event.target.removeEventListener(event.type, videoErrorHandling);
              itkLog.error('Network connection.', event);
            }
            else {
              itkLog.error('Unknown video network connection error.');
            }
            Offline.off('down');

            // Go to the next slide.
            nextSlide();
          };

          /**
           * Go to next rss news.
           * @param slide
           */
          var rssTimeout = function(slide) {
            timeout = $timeout(function () {
              if (slide.rss.rssEntry + 1 >= slide.options.rss_number) {
                nextSlide();
              }
              else {
                slide.rss.rssEntry++;
                timeout = rssTimeout(slide);
              }
            }, slide.options.rss_duration * 1000);
          };

          /**
           * Display the current slide.
           */
          var displaySlide = function () {
             // To be sure to be sure that the timeout is completed from the last slide.
            $timeout.cancel(timeout);

            // Reset the UI elements (Slide counter display x/y and progress bar.
            resetProgressBar();
            scope.progressBoxElementsIndex++;

            var slide = scope.channels[scope.displayIndex][scope.channelIndex].slides[scope.slideIndex];
            if (slide === undefined) {
              itkLog.info('No slides yet... waiting 5 seconds');

              // Wait five seconds and try again.
              $timeout(function () {
                displaySlide();
              }, 5000);
              return;
            }

            // Handle rss slide_type, video media_type or image media_type.
            if (slide.slide_type === 'rss') {
              itkLog.info('Getting rss feed' + slide.options.source);
              // Get the feed
              $http.jsonp(
                '//ajax.googleapis.com/ajax/services/feed/load?v=1.0&num=' + slide.options.rss_number + '&callback=JSON_CALLBACK&output=xml&q=' +
                encodeURIComponent(slide.options.source))
                .success(function(data) {
                  // Make sure we do not have an error result from googleapis
                  if (data.responseStatus !== 200) {
                    itkLog.error(data.responseDetails, data.responseStatus);
                    if (slide.rss && slide.rss.feed && slide.rss.feed.entries && slide.rss.feed.entries.length > 0) {
                      slide.rss.rssEntry = 0;
                      timeout = rssTimeout(slide);
                    }
                    else {
                      // Go to next slide.
                      $timeout(nextSlide, 5000);
                    }
                    return;
                  }

                  var xmlString = data.responseData.xmlString;
                  slide.rss = {feed: {entries:[]}};
                  slide.rss.rssEntry = 0;

                  slide.rss.feed.title = $sce.trustAsHtml($(xmlString).find('channel > title').text());

                  $(xmlString).find('channel > item').each(function() {
                    var entry = $(this);

                    var news = {};

                    news.title = $sce.trustAsHtml(entry.find('title').text());
                    news.description = $sce.trustAsHtml(entry.find('description').text());
                    news.date = new Date(entry.find('pubDate').text());

                    slide.rss.feed.entries.push(news);
                  });

                  timeout = rssTimeout(slide);

                  // Set the progress bar animation.
                  var dur = slide.options.rss_duration * slide.options.rss_number - 1;
                  startProgressBar(dur);
                })
                .error(function (message) {
                  itkLog.error(message);
                  if (slide.rss.feed && slide.rss.feed.entries && slide.rss.feed.entries.length > 0) {
                    slide.rss.rssEntry = 0;
                    timeout = rssTimeout(slide);
                  }
                  else {
                    // Go to next slide.
                    $timeout(nextSlide, 5000);
                  }
                });
            }
            else if (slide.media_type === 'video') {
              // If media is empty go to the next slide.
              if (slide.media.length <= 0) {
                nextSlide();
              }

              // Check if there is an internet connection.
              Offline.on('down', videoErrorHandling);
              Offline.check();
              if (Offline.state === 'down') {
                videoErrorHandling(undefined);
                return;
              }

              // Get hold of the video element.
              var video = document.getElementById('videoPlayer-' + slide.uniqueId);

              // Update video.
              updateVideoSources(video, false);

              // Add error handling.
              video.addEventListener('error', videoErrorHandling);

              // Reset video position to prevent flicker from latest playback.
              try {
                // Load video to ensure playback after possible errors from last playback. If not called
                // the video will not play.
                video.load();
                video.currentTime = 0;
              }
              catch (error) {
                itkLog.info('Video content might not be loaded, so reset current time not possible');

                // Use the error handling to get next slide.
                videoErrorHandling(undefined);
              }

              // Fade timeout to ensure video don't start before it's displayed.
              timeout = $timeout(function () {
                // Create interval to get video duration (ready state larger than one is meta-data loaded).
                var interval = $interval(function() {
                  if (video.readyState > 0) {
                    var duration = Math.round(video.duration);
                    startProgressBar(duration);

                    // Metadata/duration found stop the interval.
                    $interval.cancel(interval);
                  }
                }, 500);

                // Go to the next slide when video playback has ended.
                video.onended = function ended(event) {
                  itkLog.info("Video playback ended.", event);
                  $timeout(function () {
                    scope.$apply(function () {
                      // Remove error handling.
                      video.removeEventListener('error', videoErrorHandling);
                      Offline.off('down');

                      // Remove video src.
                      updateVideoSources(video, true);

                      // Go to the next slide.
                      nextSlide();
                    });
                  },
                  1000);
                };

                // Play the video.
                video.play();
              }, fadeTime);
            }
            else {
              // Set the progress bar animation.
              $timeout(function () {
                var dur = slide.duration;

                startProgressBar(dur);
              }, fadeTime);

              // Wait for slide duration, then show next slide.
              // + 2 seconds to account for fade in/outs.
              timeout = $timeout(function () {
                nextSlide();
              }, (slide.duration) * 1000 + fadeTime * 2);
            }
          };


          /**
           * Helper function to update source for video.
           *
           * This is due to a memory leak problem in chrome.
           *
           * @param video
           *   The video element.
           * @param reset
           *   If true src is unloaded else src is set from data-src.
           */
          var updateVideoSources = function updateVideoSources(video, reset) {
            // Due to memory leak in chrome we change the src attribute.
            var sources = video.getElementsByTagName('source');
            for (var i = 0; i < sources.length; i++) {
              if (reset) {
                // @see http://www.attuts.com/aw-snap-solution-video-tag-dispose-method/ about the pause and load.
                video.pause();
                sources[i].setAttribute('src', '');
                video.load();
              }
              else {
                sources[i].setAttribute('src', sources[i].getAttribute('data-src'));
              }
            }
          };

          /**
           * Update which slides to show next.
           * @param data
           */
          var updateSlideShow = function updateSlideShow(data) {
            var otherDisplayIndex = (scope.displayIndex + 1) % 2;
            var id = "" + data.id;

            scope.channels[otherDisplayIndex][id] = angular.copy(data);
            scope.channelKeys[otherDisplayIndex] = Object.keys(scope.channels[otherDisplayIndex]);
            scope.slidesUpdated = true;
          };

          // Event handler for 'addChannel' event.
          // Content has arrived from the middleware.
          $rootScope.$on('addChannel', function handleAddChannel(event, channel) {
            if (channel === null) {
              return;
            }

            // Check if channel should not be added to region.
            // If it should not be in region and is already,
            //   remove it from the region.
            if (channel.regions.indexOf(scope.regionId) === -1) {
              var otherDisplayIndex = (scope.displayIndex + 1) % 2;
              var id = "" + channel.data.id;

              if (scope.channels[otherDisplayIndex].hasOwnProperty(id)) {
                itkLog.info("Removing channel " + channel.data.id + " from region " + scope.regionId);

                delete scope.channels[otherDisplayIndex][id];
                scope.channelKeys[otherDisplayIndex] = Object.keys(scope.channels[otherDisplayIndex]);
                scope.slidesUpdated = true;
              }

              return;
            }

            itkLog.info("Adding channel " + channel.data.id + " to region " + scope.regionId);

            // The show is running simply update the slides.
            if (scope.running) {
              updateSlideShow(channel.data);
            }
            else {
              // The show was not running, so update the slides and start the show.
              scope.$apply(function () {
                scope.running = true;

                // Insert channel into both arrays.
                var id = "" + channel.data.id;
                scope.channels[0][id] = angular.copy(channel.data);
                scope.channels[1][id] = angular.copy(channel.data);

                // Update key arrays
                scope.channelKeys[0] = Object.keys(scope.channels[0]);
                scope.channelKeys[1] = Object.keys(scope.channels[1]);

                // Select first channel.
                channelKey = -1;

                // Make sure the slides have been loaded. Then start the show.
                $timeout(function () {
                  scope.slideIndex = -1;
                  scope.running = true;

                  // Mark channels and slides that should not be show as isScheduled = false
                  updateChannelsScheduled();
                  updateSlidesScheduled();

                  // Reset progress box
                  resetProgressBox();

                  nextChannel();
                }, 1000);
              });
            }
          });

          // Event handler for 'removeChannel' event.
          // Remove the channel from the next display array.
          $rootScope.$on('removeChannel', function removeChannelEvent(event, channel) {
            var otherDisplayIndex = (scope.displayIndex + 1) % 2;
            var id = "" + channel.id;

            // If the channel is in the array, remove it.
            if (scope.channels[otherDisplayIndex].hasOwnProperty(id)) {
              delete scope.channels[otherDisplayIndex][id];
              scope.channelKeys[otherDisplayIndex] = Object.keys(scope.channels[otherDisplayIndex]);
              scope.slidesUpdated = true;
            }
          });


        }
      }
    }
  ]);
}).call(this);

/**
 * @file
 * Contains the slide directive.
 */

/**
 * Directive to insert html for a slide.
 *
 * html parameters
 *   ik-slide (object): The slide to display (This is the variable name used in the
 *     templates, so to change this name would require that names throughout
 *     the backend and templates folder should also be changed).
 *   show (boolean): Should the slide be visible?
 *   ---- used for creation unique slide-id ----
 *   array-id (integer): The which displayIndex does this slide belong to?
 *   channel-id (integer): What channel does the slide belong to?
 *   index (integer): Which index in the channel does that slide have?
 *   region (integer): Which region does the slide belong to?
 *   ---- used for creation unique slide-id ----
 */
angular.module('ikApp').directive('slide', ['cssInjector',
  function(cssInjector) {
    'use strict';

    return {
      restrict: 'E',
      scope: {
        ikSlide: '=',
        show: '=',
        arrayId: '=',
        channelId: '=',
        index: '=',
        regionId: '=',
        scale: '='
      },
      link: function(scope, element, attrs) {
        scope.ikSlide.uniqueId = null;

        // Last time the slide was refreshed.
        var lastRefresh = 0;

        // Return af new refreshed source, with a 30 seconds interval.
        scope.ikSlide.getRefreshedSource = function() {
          if (scope.show) {
            var date = (new Date()).getTime();
            if (date - lastRefresh > 30000) {
              lastRefresh = date;
            }
          }

          // Make sure path parameters are not overridden.
          if (scope.ikSlide.options.source.indexOf('?') > 0) {
            return scope.ikSlide.options.source + "&ikrefresh=" + lastRefresh;
          }
          else {
            return scope.ikSlide.options.source + "?ikrefresh=" + lastRefresh;
          }
        };

        // Observe for changes to ik-array-id attribute. Set unique id.
        attrs.$observe('regionId', function(val) {
          if (!val) {
            return;
          }

          // Generate unique id for ikSlide.
          scope.ikSlide.uniqueId = '' + scope.regionId + '-' + scope.arrayId + '-' + scope.channelId + '-' + scope.index;
        });

        // Observe for changes to the ikSlide attribute. Setup ikSlide when set.
        attrs.$observe('ikSlide', function(val) {
          if (!val) {
            return;
          }

          // Only show first image in array.
          if (scope.ikSlide.media_type === 'image' && scope.ikSlide.media.length > 0) {
            scope.ikSlide.currentImage = scope.ikSlide.media[0].image;
          }
          else if (scope.ikSlide.media_type === 'video' && scope.ikSlide.media.length > 0) {
            // Set current video variable to path to video files.
            scope.ikSlide.currentVideo = {
              "mp4": scope.ikSlide.media[0].mp4,
              "ogg": scope.ikSlide.media[0].ogv,
              "webm": scope.ikSlide.media[0].webm
            };
          }

          // Set currentLogo.
          scope.ikSlide.currentLogo = scope.ikSlide.logo;

          // Setup the inline styling
          scope.theStyle = {
            width: "100%",
            height: "100%",
            fontsize: scope.ikSlide.options.fontsize * (scope.scale ? scope.scale : 1.0)+ "px"
          };

          if (scope.ikSlide.options.responsive_fontsize) {
            scope.theStyle.responsiveFontsize = scope.ikSlide.options.responsive_fontsize * (scope.scale ? scope.scale : 1.0)+ "vw";
          }

          // Inject stylesheet.
          cssInjector.add(scope.ikSlide.css_path);
        });

        // Cleanup videojs when ikSlide is removed.
        scope.$on('$destroy', function() {
          if (scope.ikSlide.videojs) {
            scope.ikSlide.videojs.dispose();
          }
        });
      },
      template: '<div data-ng-include="ikSlide.template_path"></div>'
    };
  }
]);

/**
 * Web-socket factory using socket.io to communicate with the middleware.
 */
angular.module('ikApp').factory('socket', ['$rootScope', 'itkLog',
  function ($rootScope, itkLog) {
    'use strict';

    var factory = {};

    // Get the load configuration object.
    var config = window.config;

    // Communication with web-socket.
    var socket;

    // Global variable with token cookie.
    var token_cookie;

    // Keeps track of connections.
    var reconnection = false;

    /**
     * Cookie object.
     *
     * Used to handle the cookie(s), mainly used to store the connection JSON Web Token.
     */
    var Cookie = (function () {
      var Cookie = function (name) {
        var self = this;

        // Get token from the cookie.
        self.get = function get() {
          var regexp = new RegExp("(?:^" + name + "|\s*" + name + ")=(.*?)(?:;|$)", "g");
          var result = regexp.exec(document.cookie);

          return (result === null) ? undefined : result[1];
        };

        // Set token.
        self.set = function set(value, expire) {
          var cookie = name + '=' + escape(value) + ';';

          if (expire === undefined) {
            expire = 'Thu, 01 Jan 2018 00:00:00 GMT';
          }
          cookie += 'expires=' + expire + ';';

          cookie += 'path=/;';
          cookie += 'domain=' + document.domain + ';';

          // Check if cookie should be available only over https.
          if (config.cookie.secure === true) {
            cookie += ' secure';
          }

          document.cookie = cookie;
        };

        // Remove the cookie by expiring it.
        self.remove = function remove() {
          self.set('', 'Thu, 01 Jan 1970 00:00:00 GMT');
        };
      };

      return Cookie;
    })();

    /**
     * Check if a valid token exists.
     *
     * If a token is found a connection to the proxy is attempted. If token
     * not found the activation form is displayed.
     *
     * If the key url-parameter is set, use that for activation.
     */
    var activation = function activation() {
      // Check if token exists.
      token_cookie = new Cookie('indholdskanalen_token');

      var token = token_cookie.get();

      if (token === undefined) {
        $rootScope.$emit("activationNotComplete");
      }
      else {
        // If token exists, connect to the socket.
        connect(token);
      }
    };

    /**
     * Load the socket.io script from the proxy server.
     */
    var loadSocket = function loadSocket(callback) {
      var file = document.createElement('script');
      file.setAttribute('type', 'text/javascript');
      file.setAttribute('src', config.resource.server + config.resource.uri + '/socket.io/socket.io.js');
      file.onload = function () {
        if (typeof io === "undefined") {
          itkLog.error("Socket.io not loaded");

          document.getElementsByTagName("head")[0].removeChild(file);
          window.setTimeout(loadSocket(callback), 100);
        } else {
          callback();
        }
      };
      document.getElementsByTagName("head")[0].appendChild(file);
    };

    /**
     * Connect to the web-socket.
     *
     * @param token
     *   JWT authentication token from the activation request.
     */
    var connect = function connect(token) {
      // Get connected to the server.
      socket = io.connect(config.ws.server, {
        'query': 'token=' + token,
        'force new connection': true,
        'max reconnection attempts': Infinity,
        'forceNew': true,
        'reconnection': true,
        'reconnectionDelay': 1000,
        'reconnectionDelayMax' : 5000,
        'reconnectionAttempts': Infinity
      });

      // Handle connected event.
      socket.on('connect', function () {
        // Connection accepted, so lets store the token.
        token_cookie.set(token);

        itkLog.log("Connection to middleware");

        // If first time we connect change reconnection to true.
        if (!reconnection) {
          reconnection = true;
        }

        // Set ready state at the server, with app initialized if this is a reconnection.
        socket.emit('ready');
      });

      // Handled deletion of screen event.
      socket.on('booted', function (data) {
        // Remove cookie with token.
        token_cookie.remove();

        // Reload application.
        location.reload(true);
      });

      /**
       * @TODO: HANDLE CHANNEL REMOVED EVENT:
       */
      socket.on('channelRemoved', function (data) {
        // Display channel ID of channel to remove.
        $rootScope.$emit('removeChannel', data);
      });

      /**
       * @TODO: HANDLE ERROR EVENT:
       */
      socket.on('error', function (error) {
        itkLog.error(error);
      });

      socket.on('disconnect', function(){
        itkLog.info('disconnect');
      });

      socket.on('reconnect', function(){
        itkLog.info('reconnect');
      });

      socket.on('reconnect_attempt', function(){
        itkLog.info('reconnect_attempt');
      });

      socket.on('connect_error', function(){
        itkLog.error('connect_error');
      });

      socket.on('reconnect_error', function(){
        itkLog.error('reconnect_error');
      });

      socket.on('reconnect_failed', function(){
        itkLog.error('reconnect_failed');
      });

      // Ready event - if the server accepted the ready command.
      socket.on('ready', function (data) {
        $rootScope.$emit('start', data.screen);

        if (data.statusCode !== 200) {
          // Screen not found will reload application on dis-connection event.
          if (data.statusCode !== 404) {
            itkLog.error('Code: ' + data.statusCode + ' - Connection error');
          }
        }
        else {
          // Only switch to awaiting content on a first time connection.
          if (!reconnection) {
            $rootScope.$emit('awaitingContent', {});
          }
        }
      });

      // Reload - if the server accepted the pause command.
      socket.on('reload', function (data) {
        // Reload browser windows (by-pass-cache).
        location.reload(true);
      });

      // Channel pushed content.
      socket.on('channelPush', function (data) {
        $rootScope.$emit('addChannel', data);
      });

      // Get logout event and send it to the middleware.
      $rootScope.$on('logout', function () {
        socket.emit('logout');
      });
    };

    /********************************
     * Public methods
     ********************************/

    /**
     * Call this to start the socket connection.
     */
    factory.start = function start() {
      loadSocket(function () {
        return activation();
      });
    };

    /**
     * Logout of the system.
     */
    factory.logout = function logout() {
      // Send socket logout event.
      $rootScope.$emit('logout');

      // Remove cookie with token.
      token_cookie.remove();

      // Reload application.
      location.reload(true);
    };

    /**
     * Activate the screen and connect.
     * @param activationCode
     *   Activation code for the screen.
     */
    factory.activateScreenAndConnect = function activateScreenAndConnect(activationCode) {
      // Build ajax post request.
      var xhr = new XMLHttpRequest();
      xhr.open('POST', config.resource.server + config.resource.uri + '/screen/activate', true);
      xhr.setRequestHeader('Content-Type', 'application/json');

      xhr.onload = function (resp) {
        if (xhr.readyState == 4 && xhr.status == 200) {
          // Success.
          resp = JSON.parse(xhr.responseText);

          // Try to get connection to the proxy.
          connect(resp.token);
        }
        else if (xhr.readyState == 4 && xhr.status == 409) {
          resp = JSON.parse(xhr.responseText);
          var dialog = confirm(resp.message);
          if (dialog == true) {
            // Create AJAX call to kick screens.
            var kickXHR = new XMLHttpRequest();
            kickXHR.open('POST', config.resource.server + config.resource.uri + '/screen/kick', true);
            kickXHR.setRequestHeader('Content-Type', 'application/json');
            kickXHR.setRequestHeader('Authorization', 'Bearer ' + resp.token);

            // Screen should be kick now so try to re-activate.
            kickXHR.onload = function (resp) {
              activateScreenAndConnect(activationCode);
            };

            // Something went wrong.
            kickXHR.onerror = function (exception) {
              // There was a connection error of some sort
              $rootScope.$apply(function() {
                itkLog.error('Kick request failed.', exception);
              });
            };

            // Send the request.
            kickXHR.send(JSON.stringify({
              "token": resp.token
            }));
          }
        }
        else {
          // We reached our target server, but it returned an error
          $rootScope.$apply(function() {
            itkLog.error(xhr.responseText, xhr);
          });
        }
      };

      xhr.onerror = function (exception) {
        // There was a connection error of some sort
        $rootScope.$apply(function() {
          itkLog.error('Activation request failed.', exception);
        });
      };

      // Send the request.
      xhr.send(JSON.stringify({
        "activationCode": activationCode,
        "apikey": config.apikey
      }));
    };

    return factory;
  }
]);

/**
 * @file
 * Contains the itkDateComponent module.
 */

/**
 * Setup the module.
 */
(function () {
  'use strict';

  var app;
  app = angular.module('itkDateComponent', []);

  /**
   * date component directive.
   *
   * html parameters:
   */
  app.directive('dateComponent', ['$interval',
    function ($interval) {
      return {
        restrict: 'E',
        replace: true,
        templateUrl: 'app/shared/components/date/date.html?' + window.config.version,
        scope: {
          theme: '@'
        },
        link: function (scope) {
          scope.thisDate = new Date();

          // Update current date every minute.
          var interval = $interval(function() {
            // Update current datetime.
            scope.thisDate = new Date();
          }, 60000);

          // Register event listener for destroy.
          //   Cleanup interval.
          scope.$on('$destroy', function() {
            if (angular.isDefined(interval)) {
              $interval.cancel(interval);
              interval = undefined;
            }
          });
        }
      };
    }
  ]);
}).call(this);

/**
 * @file
 * Contains the itkDateComponent module.
 */

/**
 * Setup the module.
 */
(function () {
  'use strict';

  var app;
  app = angular.module('itkDigitalClockComponent', []);

  /**
   * date component directive.
   *
   * html parameters:
   */
  app.directive('digitalClockComponent', ['$interval',
    function ($interval) {
      return {
        restrict: 'E',
        replace: true,
        templateUrl: 'app/shared/components/digital-clock/digital-clock.html?' + window.config.version,
        scope: {
        },
        link: function (scope) {
          scope.thisDate = new Date();

          // Update current date every minute.
          var interval = $interval(function() {
            // Update current datetime.
            scope.thisDate = Date.now();
          }, 1000);

          // Register event listener for destroy.
          //   Cleanup interval.
          scope.$on('$destroy', function() {
            if (angular.isDefined(interval)) {
              $interval.cancel(interval);
              interval = undefined;
            }
          });
        }
      };
    }
  ]);
}).call(this);

/**
 * @file
 * KeyPresses is used to capture keyboard presses.
 */

/**
 * Setup the module.
 */
(function () {
  'use strict';

  var modifierPressed = false;
  var app;
  app = angular.module("itkKeypress", []);

  app.directive('itkKeypress', function () {
    return function (scope, element, attrs) {
      element.bind("keydown keypress", function (event) {

        // Capture modifier.
        if (event.which === Number(attrs.modifier)) {
          modifierPressed = true;
          return;
        }

        // Check if modifier was pressed last.
        if(modifierPressed && event.which === Number(attrs.key)) {
          scope.$apply(function () {
            scope.$eval(attrs.itkKeypress);
          });

          // Prevent default action.
          event.preventDefault();
        }

        // Reset modifier.
        modifierPressed = false;
      });
    };
  });

}).call(this);
